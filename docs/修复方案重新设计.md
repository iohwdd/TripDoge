# 后端容错修复方案重新设计

**问题分析**: 之前的修复虽然增加了容错，但引入了严重隐患

## 发现的问题

### 1. DocController
- ❌ download: Content-Type 未设置，异常消息直接暴露
- ❌ delete: 分步执行但无一致性保证，失败信息未返回
- ❌ upload: 向量化异常静默吞掉，配置错误无提示

### 2. VectorDataService
- ❌ vectorStoreAvailable 一旦 false 就永久不可恢复
- ❌ 无重试逻辑，一次失败就永久降级
- ❌ volatile + catch 块频繁写，状态可能混乱

### 3. RedisService / UserSessionService
- ❌ 一次失败就永久标记不可用，不会恢复
- ❌ 本地 Fallback 无过期清理，内存泄露
- ❌ Session 不会过期，安全问题
- ❌ isSessionValid 等只查 Redis，本地 Fallback 时失效

## 重新设计方案

### 方案1: 健康检查 + 重试策略

#### VectorDataService
- ✅ 添加健康检查定时任务（每5分钟检查一次）
- ✅ 失败后标记为不可用，但定时检查会尝试恢复
- ✅ 使用 AtomicBoolean 替代 volatile boolean
- ✅ 添加失败计数，连续失败N次才标记为不可用

#### RedisService
- ✅ 添加健康检查定时任务（每30秒检查一次）
- ✅ 失败后标记为不可用，但定时检查会尝试恢复
- ✅ 使用 AtomicBoolean 替代 volatile boolean
- ✅ 添加失败计数和重试逻辑

### 方案2: 本地 Fallback 安全控制

#### UserSessionService
- ✅ 本地 Session 添加过期时间（使用 ScheduledExecutorService 定期清理）
- ✅ 使用 ConcurrentHashMap + 过期时间戳
- ✅ 添加最大 Session 数量限制（防止内存泄露）
- ✅ isSessionValid、getSessionRemainingTime 同时检查 Redis 和本地内存
- ✅ removeSession 返回操作结果，暴露 Redis 错误

### 方案3: DocController 响应完善

#### download
- ✅ 设置正确的 Content-Type (text/plain; charset=UTF-8)
- ✅ 异常消息不直接暴露，使用错误码
- ✅ 返回统一的错误响应格式

#### delete
- ✅ 返回详细的操作结果（哪些成功，哪些失败）
- ✅ 使用 Result 对象包含失败详情
- ✅ 部分失败时返回警告状态码（207 Multi-Status）

#### upload
- ✅ 向量化失败时返回警告，不静默吞掉
- ✅ 区分配置错误和临时错误
- ✅ 在响应中标注向量化状态

## 实施计划

### Phase 1: 回退当前修改
- [ ] 回退所有修改的文件

### Phase 2: 重新实现健康检查机制
- [ ] VectorDataService: 添加定时健康检查
- [ ] RedisService: 添加定时健康检查
- [ ] 使用 AtomicBoolean 和失败计数

### Phase 3: 完善本地 Fallback
- [ ] UserSessionService: 添加过期清理
- [ ] 添加最大数量限制
- [ ] 完善 isSessionValid 等方法

### Phase 4: 完善 DocController
- [ ] download: 修复 Content-Type 和错误处理
- [ ] delete: 返回详细操作结果
- [ ] upload: 向量化失败时返回警告

## 代码质量要求

1. ✅ 所有降级都有恢复机制
2. ✅ 本地 Fallback 有安全控制（TTL、清理、限制）
3. ✅ 错误信息不直接暴露给前端
4. ✅ 操作结果明确标注成功/失败
5. ✅ 配置错误和临时错误区分处理

