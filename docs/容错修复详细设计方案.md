# 后端容错修复详细设计方案

## 设计原则

1. **可恢复性**: 所有降级都有恢复机制，不会永久失效
2. **安全性**: 本地Fallback有TTL、清理、数量限制
3. **可观测性**: 操作结果明确标注，错误信息不直接暴露
4. **一致性**: 分步操作有明确的状态反馈

## 1. VectorDataService - 健康检查机制

### 设计要点
- 使用 `AtomicBoolean` 替代 `volatile boolean`
- 添加失败计数（连续失败N次才标记为不可用）
- 定时健康检查（每5分钟），可以自动恢复
- 失败时记录时间戳，避免频繁切换状态

### 实现方案
```java
private final AtomicBoolean vectorStoreAvailable = new AtomicBoolean(true);
private final AtomicInteger consecutiveFailures = new AtomicInteger(0);
private volatile long lastFailureTime = 0;
private static final int MAX_CONSECUTIVE_FAILURES = 3;
private static final long HEALTH_CHECK_INTERVAL = 5 * 60 * 1000; // 5分钟

@Scheduled(fixedDelay = HEALTH_CHECK_INTERVAL)
public void healthCheck() {
    if (!vectorStoreAvailable.get()) {
        // 尝试恢复
        try {
            // 简单的健康检查操作
            vectorStoreAvailable.set(true);
            consecutiveFailures.set(0);
            log.info("向量存储健康检查通过，已恢复");
        } catch (Exception e) {
            log.debug("向量存储健康检查失败，继续降级: {}", e.getMessage());
        }
    }
}
```

## 2. RedisService - 健康检查机制

### 设计要点
- 使用 `AtomicBoolean` 和失败计数
- 定时健康检查（每30秒），可以自动恢复
- 失败时记录时间戳

### 实现方案
```java
private final AtomicBoolean redisAvailable = new AtomicBoolean(true);
private final AtomicInteger consecutiveFailures = new AtomicInteger(0);
private static final int MAX_CONSECUTIVE_FAILURES = 3;
private static final long HEALTH_CHECK_INTERVAL = 30 * 1000; // 30秒

@Scheduled(fixedDelay = HEALTH_CHECK_INTERVAL)
public void healthCheck() {
    if (!redisAvailable.get()) {
        try {
            redisTemplate.opsForValue().set("health_check", "ok", 1, TimeUnit.SECONDS);
            redisAvailable.set(true);
            consecutiveFailures.set(0);
            log.info("Redis健康检查通过，已恢复");
        } catch (Exception e) {
            log.debug("Redis健康检查失败，继续降级: {}", e.getMessage());
        }
    }
}
```

## 3. UserSessionService - 本地Fallback安全控制

### 设计要点
- 本地Session添加过期时间（使用带时间戳的包装类）
- 定期清理过期Session（每5分钟）
- 最大Session数量限制（防止内存泄露）
- isSessionValid、getSessionRemainingTime 同时检查Redis和本地内存

### 实现方案
```java
// Session包装类，包含过期时间
private static class SessionWrapper {
    final UserInfoVO userInfo;
    final long expireTime;
    
    SessionWrapper(UserInfoVO userInfo, long expireTime) {
        this.userInfo = userInfo;
        this.expireTime = expireTime;
    }
    
    boolean isExpired() {
        return System.currentTimeMillis() > expireTime;
    }
}

private final ConcurrentHashMap<String, SessionWrapper> localSessionStore = new ConcurrentHashMap<>();
private final ConcurrentHashMap<Long, String> localUserTokenMap = new ConcurrentHashMap<>();
private static final int MAX_LOCAL_SESSIONS = 10000; // 最大Session数量

@Scheduled(fixedDelay = 5 * 60 * 1000) // 每5分钟清理一次
public void cleanupExpiredSessions() {
    long now = System.currentTimeMillis();
    localSessionStore.entrySet().removeIf(entry -> {
        boolean expired = entry.getValue().isExpired();
        if (expired) {
            String token = entry.getKey().replace(SESSION_KEY_PREFIX, "");
            localUserTokenMap.values().removeIf(t -> t.equals(token));
        }
        return expired;
    });
    log.debug("清理过期Session完成，当前Session数量: {}", localSessionStore.size());
}
```

## 4. DocController - 完善的错误处理

### download方法
- 设置正确的Content-Type
- 异常消息不直接暴露，使用错误码
- 返回统一的错误响应格式

### delete方法
- 返回详细的操作结果（哪些成功，哪些失败）
- 使用Result对象包含失败详情
- 部分失败时返回警告状态

### upload方法
- 向量化失败时返回警告，不静默吞掉
- 区分配置错误和临时错误
- 在响应中标注向量化状态

## 实施步骤

1. ✅ 回退当前修改
2. ⏳ 实现VectorDataService健康检查
3. ⏳ 实现RedisService健康检查
4. ⏳ 实现UserSessionService本地Fallback安全控制
5. ⏳ 修复DocController错误处理


